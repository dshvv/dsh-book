---
title: 第5.2章 打包器
hide_title: true
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import WebpackBuildMain from "!!raw-loader!/src/components/DocsFe/WebpackBuild/main.js";
import WebpackBuilUtils from "!!raw-loader!/src/components/DocsFe/WebpackBuild/utils_js.js";
import CodeBlock from "@theme/CodeBlock";


### webpack

模块打包器，更多请看[官网教程](https://webpack.docschina.org)。  
[模块化技术](https://www.cnblogs.com/dingshaohua/p/8371018.html) 2015 年 在前端兴起。  
使用此技术，可以让代码变整洁、清晰。

<Tabs>
<TabItem value="index.html" label="index.html" default>

```html
<button>1+2=?</button>
<script src="./index.js"></script>
```

</TabItem>
<TabItem value="index.js" label="index.js">

```js
const btn = document.querySelector("button");

btn.onclick = async () => {
  const { add } = await import("./utils.js");
  const res = add(1, 2);
  console.log(res);
};
```

</TabItem>
<TabItem value="utils.js" label="utils.js">

```js
export const add = (x, y) => {
  return x + y;
};
```

</TabItem>

</Tabs>

😒😒😒😒😒😒😒😒😒😒  
不过，截至到 2022 年，  
也就最新的 chrome 实现了对模块化的支持。  
其它浏览器均会无法识别。  
![fe-5.3](/img/fe/5.3.jpg)

👇👇🌹🌺🌻🌼🌸💐👇👇  
于是，webpack 上场了。

> 引用官方的话：webpack 是 js 模块处理的工具、模块打包器。它根据模块的依赖关系进行分析，然后生成对应的静态资源。

如上代码，用 webpack 处理：

```shell
webpack ./index.js --mode=development
```

命令执行完成后，会在项目根目录下生成`dist`目录，这里边就是其处理好的 js 文件。最后 `index.html` 里引入即可。

<Tabs>
<TabItem value="index.html" label="index.html" default>

```html title="index.html"
<button>1+2=?</button>
<script src="./dist/main.js"></script>
```

</TabItem>
 <TabItem value="main.js" label="main.js">
    <CodeBlock language="js" title="dist/main.js">
      {WebpackBuildMain}
    </CodeBlock>
  </TabItem>
  <TabItem value="utils_js.js" label="utils_js.js">
    <CodeBlock language="js" title="dist/utils_js.js">
      {WebpackBuilUtils}
    </CodeBlock>
  </TabItem>
</Tabs>

可以看到 webpack 对分包的处理，特别的复杂,
完全自己实现了一套模块化处理机制方案，来兼容个大浏览器。

### rollup

模块打包器，更多请看[官网教程](https://www.rollupjs.com)。  
和 webpack 功能基本一样，是其竞品。不过和 webpack 的区别在于：  
1、它小巧，仅是款 ESM 打包器，无其它功能。  
2、它利用 ESM 支撑，非 webpack 特殊处理。  
3、它不支持模块的 HMR 热更新。

拿上面 webpack 那个例子，改为 rollup 编译

```shell
# rollup 入口文件    -d 输出目录
  rollup .\index.js  -d dist
```

命令执行完成后，会在项目根目录下生成`build`目录，这里边就是其处理好的 js 文件。最后 `index.html` 里引入即可。

<Tabs>
<TabItem value="index.html" label="index.html">

```html title="index.html"
<button>1+2=?</button>
<script src="./build/index.js"></script>
```

</TabItem>
<TabItem value="index.js" label="index.js">

```js title="build/index.js"
const btn = document.querySelector("button");

btn.onclick = async () => {
  const { add } = await import("./utils-123.js");
  const res = add(1, 2);
  console.log(res);
};
```

</TabItem>
<TabItem value="utils-5c8046dd.js" label="utils-123.js">

```js title="build/utils-123.js"
const add = (x, y) => {
  return x + y;
};

export { add };
```

</TabItem>
</Tabs>

可以看到，打包后的代码和源码没什么区别。  
代码的执行仍依赖于浏览器本身对模块化的支持，所以我觉得它处理了个寂寞 😂。

📣 得出结论，webpack 和 babel 应用场景不同：
应用开发用 前者，类库的开发则用 后者

### esbuild
模块打包器，同事也具备babel的功能。

拿上面 webpack 那个例子，改为 esbuild 编译
--bundle 表示需要编译，默认原样输出     
--splitting 代表分割代码，默认不分割   
--format=esm 代表输出模块类型，splitting仅支持esm   

```shell
  esbuild ./src/index.js --bundle --outdir=build --splitting --format=esm
```

命令执行完成后，会在项目根目录下生成`build`目录，这里边就是其处理好的 js 文件。最后 `index.html` 里引入即可。

<Tabs>
<TabItem value="index.html" label="index.html">

```html title="index.html"
<button>1+2=?</button>
<script src="./build/index.js"></script>
```

</TabItem>
<TabItem value="index.js" label="index.js">

```js title="build/index.js"
// src/index.js
var btn = document.querySelector("button");
btn.onclick = async () => {
  const { add } = await import("./utils-YOWK4GEG.js");
  const res = add(1, 2);
  console.log(res);
};
```

</TabItem>
<TabItem value="utils-5c8046dd.js" label="utils-123.js">

```js title="build/utils-123.js"
// src/utils.js
var add = (x, y) => {
  return x + y;
};
export {
  add
};

```

</TabItem>
</Tabs>

可以看出 跟rollup处理模块化的方式 异曲同工之妙！
https://esbuild.github.io/



<!-- 前端工程化工具总结和对比
包管理工具
经过验证、较稳定的构建工具
较新的构建工具
自动化构建工具 -->
